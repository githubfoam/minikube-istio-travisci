---
sudo: required
dist: bionic
env:
  global:
  #fleet_script_minikube_tasks
  - KUBECTL_VERSION=1.18.1
  - KUBERNETES_VERSION=1.18.1
  - MINIKUBE_VERSION=1.8.1
  - CHANGE_MINIKUBE_NONE_USER=true #(bool) automatically change ownership of ~/.minikube to the value of $SUDO_USER https://minikube.sigs.k8s.io/docs/handbook/config/
  - MINIKUBE_WANTREPORTERRORPROMPT=false
  - MINIKUBE_WANTUPDATENOTIFICATION=false #(bool) sets whether the user wants an update notification for new minikube versions https://minikube.sigs.k8s.io/docs/handbook/config
  - MINIKUBE_HOME=$HOME #(string) sets the path for the .minikube directory that minikube uses for state/configuration. Please note: this is used only by minikube https://minikube.sigs.k8s.io/docs/handbook/config
  - KUBECONFIG=$HOME/.kube/config
  # - ISTIO_VERSION=1.6.0
notifications:
  slack:
    on_failure: always



fleet_script_minikube_knative_istio_serverless_tasks : &fleet_script_minikube_knative_istio_serverless_tasks
      script:
          - set -eux #safety for script
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.18.1/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.8.1/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - mkdir -p $HOME/.kube $HOME/.minikube
          # - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v1.18.1 #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - |
            sudo -E minikube start \
            --memory=8192 --cpus=4 \
            --kubernetes-version=v$KUBERNETES_VERSION \
            --vm-driver=none --bootstrapper=kubeadm --alsologtostderr \
            --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook"
          - minikube update-context
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          # - minikube update-context --profile=minikube
          # - "sudo chown -R travis: /home/travis/.minikube/"
          # - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
          - echo "================================Install istio=========================================================="
          - curl -L https://raw.githubusercontent.com/knative/serving/v0.1.1/third_party/istio-0.8.0/istio.yaml | sed 's/LoadBalancer/NodePort/'  | kubectl apply -f - ## Install Istio
          - kubectl label namespace default istio-injection=enabled # Label the default namespace with istio-injection=enabled
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 10
            done
          - kubectl get pods --namespace=istio-system
          - echo "================================Install knative=========================================================="
          - curl -L https://github.com/knative/serving/releases/download/v0.1.1/release-lite.yaml | sed 's/LoadBalancer/NodePort/' | kubectl apply -f
          - |
            for i in {1..60}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
                break
              fi
              sleep 5
            done
          - kubectl get pods --namespace=knative-serving
          - echo "=========================================================================================="
          - - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')

fleet_script_minikube_knative_ambassador_serverless_tasks : &fleet_script_minikube_knative_ambassador_serverless_tasks
      script:
          - set -eux #safety for script
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.18.1/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.8.1/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - mkdir -p $HOME/.kube $HOME/.minikube
          # - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v1.18.1 #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - |
            sudo -E minikube start \
            --memory=8192 --cpus=4 \
            --kubernetes-version=v$KUBERNETES_VERSION \
            --vm-driver=none --bootstrapper=kubeadm --alsologtostderr \
            --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook"
          - minikube update-context
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          # - minikube update-context --profile=minikube
          # - "sudo chown -R travis: /home/travis/.minikube/"
          # - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
          - echo "================================Install istio=========================================================="
          - curl -L https://raw.githubusercontent.com/knative/serving/v0.1.1/third_party/istio-0.8.0/istio.yaml | sed 's/LoadBalancer/NodePort/'  | kubectl apply -f - ## Install Istio
          - kubectl label namespace default istio-injection=enabled # Label the default namespace with istio-injection=enabled
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 10
            done
          - kubectl get pods --namespace=istio-system
          - echo "================================Install knative=========================================================="
          - curl -L https://github.com/knative/serving/releases/download/v0.1.1/release-lite.yaml | sed 's/LoadBalancer/NodePort/' | kubectl apply -f
          - |
            for i in {1..60}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
                break
              fi
              sleep 5
            done
          - kubectl get pods --namespace=knative-serving
          - echo "=========================================================================================="
          - - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
fleet_script_minikube_knative_tasks : &fleet_script_minikube_knative_tasks
      script:
          # - set -eux #safety for script
          - set -e #safety for script
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube  --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - |
            sudo minikube start \
             --profile=minikube \
             --disk-size=30g \
             --vm-driver=none \
             --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook" \
             --kubernetes-version=v$KUBERNETES_VERSION
          # The 'none' driver does not respect the --cpus flag ! The 'none' driver does not respect the --memory flag
          # - sudo minikube start --profile=minikube --memory=8192 --cpus=4 --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "================================Install istio=========================================================="
          - export ISTIO_VERSION=1.4.6
          - curl -L https://git.io/getLatestIstio | sh - && cd istio-${ISTIO_VERSION}
          - for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done #Install Istio CRDs
          # - kubectl create ns istio-system #Create istio-system namespace
          # - kubectl label ns istio-system istio-injection=disabled
          #Create istio-system namespace
          - |
            cat <<EOF | sudo kubectl apply -f -
            apiVersion: v1
            kind: Namespace
            metadata:
              name: istio-system
              labels:
                istio-injection: disabled
            EOF
          - sudo apt install snapd -y && sudo snap install helm --classic # Install  helm 3.2.1 from Snapcrafters installed
          # https://knative.dev/docs/install/installing-istio/  Installing Istio without sidecar injection Generate istio-lean.yaml
          - |
            sudo helm template --namespace=istio-system \
            	  --set prometheus.enabled=false \
                --set mixer.enabled=false \
                --set mixer.policy.enabled=false \
                --set mixer.telemetry.enabled=false \
                `# Pilot doesn't need a sidecar.` \
                --set pilot.sidecar=false \
                --set pilot.resources.requests.memory=128Mi \
                `# Disable galley (and things requiring galley).` \
                --set galley.enabled=false \
                --set global.useMCP=false \
                `# Disable security / policy.` \
                --set security.enabled=false \
                --set global.disablePolicyChecks=true \
                `# Disable sidecar injection.` \
                --set sidecarInjectorWebhook.enabled=false \
                --set global.proxy.autoInject=disabled \
                --set global.omitSidecarInjectorConfigMap=true \
                --set gateways.istio-ingressgateway.autoscaleMin=1 \
                --set gateways.istio-ingressgateway.autoscaleMax=2 \
                `# Set pilot trace sampling to 100%` \
                --set pilot.traceSampling=100 \
                --set global.mtls.auto=false \
                install/kubernetes/helm/istio \
                > ./istio-lean.yaml
          - kubectl apply -f istio-lean.yaml && cd .. # Install Istio using istio-lean.yaml
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 30
            done
          - kubectl get pods --namespace istio-system #Verifying your Istio install
          - kubectl get svc -nistio-system #look up the external IP address that Istio received
          # https://knative.dev/docs/install/any-kubernetes-cluster/ Installing the Serving component
          # - echo "================================Install knative Installing the Serving component =========================================================="
          # - |
          #   sudo kubectl apply \
          #    --filename https://github.com/knative/serving/releases/download/v0.14.0/serving-crds.yaml \ #Install the Custom Resource Definitions (aka CRDs)
          #    --filename https://github.com/knative/serving/releases/download/v0.14.0/serving-core.yaml \ #Install the core components of Serving
          #    `#--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml` # Monitoring was disabled because it's too heavy for Minikube
          # - echo "================================Install knative=========================================================="
          # - |
          #   sudo kubectl apply \
          #    --filename https://github.com/knative/serving/releases/download/v0.11.0/serving.yaml \
          #    --filename https://github.com/knative/eventing/releases/download/v0.11.0/release.yaml \
          #    `#--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml` # Monitoring was disabled because it's too heavy for Minikube
          # - echo "================================Istio External IP Address=========================================================="
          # - export INGRESSGATEWAY=istio-ingressgateway
          # - export EXTERNAL_IP_ADDRESS=$(minikube ip):$(kubectl get svc $INGRESSGATEWAY --namespace istio-system --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
          # - echo "EXTERNAL_IP_ADDRESS=$EXTERNAL_IP_ADDRESS"
          # - echo "To export Istio External IP Address:         export EXTERNAL_IP_ADDRESS=$EXTERNAL_IP_ADDRESS"
          # - kubectl get pods --all-namespaces
          # - |
          #   for i in {1..30}; do # Timeout after 5 minutes
          #     if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
          #     	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
          #     	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
          #       break
          #     fi
          #     sleep 10
          #   done
          # - kubectl get pods --namespace=knative-serving
          # - echo "=========================================================================================="
          # - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')

fleet_script_istio_tasks : &fleet_script_istio_tasks
      script:
          - egrep -c '(vmx|svm)' /proc/cpuinfo | echo "virtualization is  supported" | echo "virtualization is not supported"
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "============================Waiting for Kubernetes to be ready=============================================================="
          - |
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - kubectl config use-context minikube #switch to the minikube context, so we can talk to the cluster
          - echo "==================================Install istio========================================================"
          - 'curl -L https://git.io/getLatestIstio | sh -' #Download and install the latest Istio release
          - ln -s $PWD/istioctl /usr/local/bin/istioctl #start by creating a symbolic link for istioctl (alternatively, you can copy the binary to /usr/local/bin)
          - echo "=========================================================================================="
          - istioctl version
          - echo "=========================================================================================="
          - kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml #Install Istio custom resource definitions and wait for about a minute or so for the CRDs to get applied
          - kubectl apply -f install/kubernetes/istio-demo-auth.yaml #Install Istio with mutual TLS authentication
          - echo "============================Waiting for istio to be ready=============================================================="
          - |
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=istio-system |grep Running ; then
                break
              fi
              sleep 2
            done
          - kubectl get pods -n istio-system #have successfully installed Istio on a Minikube Kubernetes cluster

fleet_script_tasks : &fleet_script_tasks
      script:
        - python --version
fleet_install_tasks : &fleet_install_tasks
      install:
        - pip install -r requirements.txt


matrix:
  fast_finish: true
  include:

    - name: "minikube linkerd Python 3.7 on bionic" #OK
      dist: bionic
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
      <<: *fleet_install_tasks
      <<: *fleet_script_tasks
      <<: *fleet_script_istio_tasks
      after_success:
        - deactivate

    # - name: "minikube service mesh istio knative ambassador serverless  Python 3.7 on bionic"
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_knative_ambassador_serverless_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube service mesh istio knative Python 3.7 on bionic"
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_knative_tasks
    #   after_success:
    #     - deactivate

    # - name: "packer latest Python 3.7 on bionic" #OK
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_packer_latest_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube microservice Python 3.7 on bionic" #OK
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   <<: *fleet_script_vagrant_latest_tasks
    #   # <<: *fleet_script_minikube_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube latest microservice Python 3.7 on xenial" #OK
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   <<: *fleet_script_minikube_latest_tasks
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on bionic arm64" # package architecture (amd64) does not match system (arm64)
    #   os: linux
    #   arch: arm64
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate


    # - name: "Python 2.7 on xenial amd64"
    #   dist: xenial
    #   language: python
    #   python: 2.7
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on xenial arm64"
    #   os: linux
    #   arch: arm64
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate




    # - name: "Python 2.7.17 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate
    #
    #
    #
    #
    # - name: "Python 3.7.5 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7.5 on macOS xcode9.4 "
    #   os: osx
    #   osx_image: xcode9.4
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate



    # - name: "Python 3.8 on Windows"
    #   os: windows
    #   language: shell
    #   env:
    #     - PATH=/c/Python38:/c/Python38/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.8.1
    #     - pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_win_tasks
    #   <<: *fleet_script_vagrant_win_scoop_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on Windows"
    #   os: windows
    #   language: shell
    #   env: PATH=/c/Python37:/c/Python37/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.7.3
    #     - python -m pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_win_tasks
    #   <<: *fleet_script_vagrant_win_scoop_tasks
    #   after_success:
    #     - deactivate
